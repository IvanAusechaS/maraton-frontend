# üêõ Backend Issue: Nueva Pel√≠cula No Aparece en Favoritos

## üìã Descripci√≥n del Problema

Cuando el usuario a√±ade una pel√≠cula a favoritos desde `MovieDetailPage`, la pel√≠cula **NO aparece** inmediatamente en la lista de favoritos en `MoviePage`, aunque el frontend hace todo correctamente.

### Escenario de Prueba

1. ‚úÖ Usuario a√±ade pel√≠cula ID **45** a favoritos
2. ‚úÖ Frontend llama correctamente: `POST /api/usuarios/favorites` con `{peliculaId: 45}`
3. ‚úÖ Backend responde 200 OK
4. ‚úÖ Frontend recarga favoritos: `GET /api/usuarios/favorites`
5. ‚ùå Backend solo retorna pel√≠culas **[42, 25]** (NO incluye la 45)

**Resultado esperado**: Backend deber√≠a retornar **[42, 25, 45]**

---

## üîç Diagn√≥stico

### Frontend (‚úÖ Funcionando Correctamente)

```javascript
// 1. A√±adir a favoritos
POST http://localhost:3000/api/usuarios/favorites
Body: { peliculaId: 45 }
Headers: { 'Content-Type': 'application/json' }
Credentials: include (cookie con JWT)

// Response: 200 OK
{
  "message": "Pelicula a√±adida a favoritos",
  "gusto": { ... }
}

// 2. Inmediatamente despu√©s, recarga favoritos
GET http://localhost:3000/api/usuarios/favorites
Credentials: include

// Response: 200 OK
{
  "total": 2,
  "movies": [
    { id: 42, titulo: "...", ... },
    { id: 25, titulo: "...", ... }
    // ‚ùå FALTA: { id: 45, titulo: "...", ... }
  ]
}
```

### Logs del Frontend

```
‚ûï [MovieDetailPage] Adding to favorites... (movie ID: 45)
üì¢ [MovieDetailPage] Calling notifyFavoritesChange()
üîÑ [FavoritesContext] Version changing from 1 to 2
‚úÖ [MoviePage] User authenticated, fetching favorites...
üì• [MoviePage] Favorites fetched: 2 movies  ‚Üê ‚ùå Deber√≠a ser 3
üé¨ [MoviePage] Movies IDs: [42, 25]        ‚Üê ‚ùå Falta el 45
```

---

## üö® Posibles Causas en el Backend

### Causa 1: POST No Est√° Guardando Correctamente

**Archivo**: `src/routes/usuario.ts` - Endpoint `POST /favorites`

**Posible problema**:
```typescript
router.post("/favorites", verify, async (req, res) => {
  const movieId = req.body.peliculaId;
  const userId = req.user.id;
  
  try {
    const user = await prisma.usuario.findUnique({
      where: {
        id: userId  // ‚ö†Ô∏è ¬øEst√° llegando correctamente el userId del JWT?
      }
    });
    
    // ‚ö†Ô∏è ¬øSe est√° verificando que la pel√≠cula exista?
    const movie = await prisma.pelicula.findUnique({
      where: { id: movieId }
    });
    
    if (!movie) {
      // Si la pel√≠cula no existe, deber√≠a retornar error
      return res.status(404).json({ error: "Pelicula no encontrada" });
    }

    // ‚ö†Ô∏è ¬øSe est√° creando o actualizando el registro en la tabla "gusto"?
    const gusto = await prisma.gusto.create({
      data: {
        usuarioId: userId,
        peliculaId: movieId,
        favoritos: true,
        reproducida: false,
        ver_mas_tarde: false
      }
    });
    
    res.status(201).json({
      message: "Pelicula a√±adida a favoritos",
      gusto: gusto
    });
    
  } catch (error) {
    // ‚ö†Ô∏è ¬øQu√© error se est√° capturando?
    console.error("Error adding to favorites:", error);
    res.status(500).json({ error: "Error interno" });
  }
});
```

**Verificar**:
1. ¬øEl `userId` del JWT es correcto? (`req.user.id`)
2. ¬øLa pel√≠cula con ID 45 existe en la tabla `peliculas`?
3. ¬øSe est√° creando el registro en la tabla `gusto`?
4. ¬øHay alg√∫n error de constraint/unique en la base de datos?

---

### Causa 2: GET No Est√° Retornando Todas las Pel√≠culas

**Archivo**: `src/routes/usuario.ts` - Endpoint `GET /favorites`

**Posible problema**:
```typescript
router.get("/favorites", verify, async (req, res) => {
  const userId = req.user.id;
  
  try {
    const gustos = await prisma.gusto.findMany({
      where: {
        usuarioId: userId,
        favoritos: true  // ‚ö†Ô∏è ¬øEste filtro est√° correcto?
      },
      include: {
        pelicula: true  // ‚ö†Ô∏è ¬øLa relaci√≥n est√° bien definida?
      }
    });
    
    const movies = gustos.map(gusto => gusto.pelicula);
    
    res.json({
      total: movies.length,
      movies: movies
    });
    
  } catch (error) {
    console.error("Error fetching favorites:", error);
    res.status(500).json({ error: "Error interno" });
  }
});
```

**Verificar**:
1. ¬øLa query de `findMany` est√° usando el `userId` correcto?
2. ¬øEl campo `favoritos` es booleano y est√° en `true`?
3. ¬øLa relaci√≥n `gusto.pelicula` est√° bien definida en el schema de Prisma?
4. ¬øHay alg√∫n soft-delete o filtro adicional que oculte la pel√≠cula?

---

### Causa 3: Problema con el Schema de Prisma

**Archivo**: `prisma/schema.prisma`

**Verificar la relaci√≥n**:
```prisma
model Gusto {
  id            Int      @id @default(autoincrement())
  favoritos     Boolean  @default(false)
  reproducida   Boolean  @default(false)
  ver_mas_tarde Boolean  @default(false)
  calificacion  Int?
  
  usuarioId     Int
  peliculaId    Int
  
  usuario       Usuario  @relation(fields: [usuarioId], references: [id])
  pelicula      Pelicula @relation(fields: [peliculaId], references: [id])
  
  @@unique([usuarioId, peliculaId])  // ‚ö†Ô∏è Esta constraint es importante
}
```

**Problema potencial**:
- Si ya existe un registro con `usuarioId=5` y `peliculaId=45` con `favoritos=false`
- El `POST` deber√≠a hacer `upsert` en lugar de `create`

---

## ‚úÖ Soluci√≥n Recomendada

### Fix para POST /favorites (Usar UPSERT)

```typescript
router.post("/favorites", verify, async (req, res) => {
  const movieId = req.body.peliculaId;
  const userId = req.user.id;
  
  // Validar input
  if (!movieId || isNaN(movieId)) {
    return res.status(400).json({ error: "peliculaId inv√°lido" });
  }
  
  try {
    // Verificar que el usuario existe
    const user = await prisma.usuario.findUnique({
      where: { id: userId }
    });
    
    if (!user) {
      return res.status(404).json({ error: "Usuario no encontrado" });
    }
    
    // Verificar que la pel√≠cula existe
    const movie = await prisma.pelicula.findUnique({
      where: { id: movieId }
    });
    
    if (!movie) {
      return res.status(404).json({ error: "Pelicula no encontrada" });
    }
    
    // ‚úÖ USAR UPSERT en lugar de CREATE
    const gusto = await prisma.gusto.upsert({
      where: {
        usuarioId_peliculaId: {
          usuarioId: userId,
          peliculaId: movieId
        }
      },
      update: {
        favoritos: true  // Si ya existe, actualizar a true
      },
      create: {
        usuarioId: userId,
        peliculaId: movieId,
        favoritos: true,
        reproducida: false,
        ver_mas_tarde: false
      }
    });
    
    res.status(201).json({
      message: "Pelicula a√±adida a favoritos",
      gusto: gusto
    });
    
  } catch (error) {
    console.error("Error adding to favorites:", error);
    
    // M√°s detalle en el error para debugging
    res.status(500).json({ 
      error: "No se pudo a√±adir a favoritos",
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});
```

### Fix para GET /favorites (Mejor Query)

```typescript
router.get("/favorites", verify, async (req, res) => {
  const userId = req.user.id;
  
  try {
    const gustos = await prisma.gusto.findMany({
      where: {
        usuarioId: userId,
        favoritos: true
      },
      include: {
        pelicula: {
          include: {
            idioma: true,  // Incluir idioma si es necesario
            generos: true  // Incluir g√©neros si es necesario
          }
        }
      },
      orderBy: {
        id: 'desc'  // M√°s recientes primero
      }
    });
    
    // Extraer solo las pel√≠culas
    const movies = gustos.map(gusto => gusto.pelicula);
    
    // Log para debugging (remover en producci√≥n)
    console.log(`‚úÖ User ${userId} has ${movies.length} favorites:`, movies.map(m => m.id));
    
    res.json({
      total: movies.length,
      movies: movies
    });
    
  } catch (error) {
    console.error("‚ùå Error fetching favorites for user", userId, ":", error);
    res.status(500).json({ 
      message: "No se pudieron obtener favoritos, intentalo de nuevo mas tarde",
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});
```

---

## üß™ C√≥mo Verificar

### 1. Verificar que el POST funciona

```bash
# Desde el backend, ejecutar en la terminal:
curl -X POST http://localhost:3000/api/usuarios/favorites \
  -H "Content-Type: application/json" \
  -H "Cookie: authToken=TU_TOKEN_JWT" \
  -d '{"peliculaId": 45}'

# Expected response:
{
  "message": "Pelicula a√±adida a favoritos",
  "gusto": {
    "id": 123,
    "usuarioId": 5,
    "peliculaId": 45,
    "favoritos": true,
    "reproducida": false,
    "ver_mas_tarde": false,
    "calificacion": null
  }
}
```

### 2. Verificar directamente en la base de datos

```sql
-- Conectar a la base de datos y ejecutar:
SELECT * FROM "Gusto" WHERE "usuarioId" = 5 AND "peliculaId" = 45;

-- Deber√≠a retornar:
-- id | usuarioId | peliculaId | favoritos | reproducida | ver_mas_tarde | calificacion
-- 123| 5         | 45         | true      | false       | false         | null
```

### 3. Verificar que el GET retorna la pel√≠cula

```bash
curl http://localhost:3000/api/usuarios/favorites \
  -H "Cookie: authToken=TU_TOKEN_JWT"

# Expected response:
{
  "total": 3,
  "movies": [
    { "id": 45, "titulo": "...", ... },  # ‚Üê La pel√≠cula reci√©n a√±adida
    { "id": 42, "titulo": "...", ... },
    { "id": 25, "titulo": "...", ... }
  ]
}
```

---

## üìä Tabla de Debugging

| Paso | Acci√≥n | ¬øFunciona? | Comando de Verificaci√≥n |
|------|--------|------------|-------------------------|
| 1 | POST a√±ade registro a DB | ‚ùì | `SELECT * FROM "Gusto" WHERE "peliculaId" = 45` |
| 2 | GET retorna la pel√≠cula | ‚ùì | `curl .../favorites` con cookie |
| 3 | Pel√≠cula existe en DB | ‚ùì | `SELECT * FROM "Pelicula" WHERE id = 45` |
| 4 | Usuario existe | ‚úÖ | Usuario ID 5 est√° logueado |
| 5 | JWT tiene userId correcto | ‚ùì | Verificar payload del JWT |

---

## üîß Checklist para el Equipo Backend

- [ ] Verificar que la pel√≠cula ID 45 existe en `Pelicula` table
- [ ] Verificar que `POST /favorites` usa `upsert` en lugar de `create`
- [ ] Verificar que `GET /favorites` no tiene filtros adicionales ocultos
- [ ] A√±adir logs de debugging en ambos endpoints
- [ ] Verificar la constraint `@@unique([usuarioId, peliculaId])` en el schema
- [ ] Probar manualmente con `curl` o Postman
- [ ] Verificar directamente en la base de datos con SQL
- [ ] Confirmar que no hay soft-deletes o estados adicionales

---

## üìù Logs Recomendados para Debugging

A√±adir estos logs temporalmente en el backend:

```typescript
// En POST /favorites
console.log("üì• POST /favorites - userId:", userId, "peliculaId:", movieId);
console.log("‚úÖ Gusto created/updated:", gusto);

// En GET /favorites
console.log("üì• GET /favorites - userId:", userId);
console.log("‚úÖ Found", gustos.length, "gustos");
console.log("‚úÖ Movie IDs:", gustos.map(g => g.peliculaId));
```

---

## üéØ Resultado Esperado

Despu√©s de aplicar los fixes:

1. ‚úÖ Usuario a√±ade pel√≠cula 45 a favoritos
2. ‚úÖ Backend guarda correctamente en la tabla `Gusto`
3. ‚úÖ Frontend recarga favoritos
4. ‚úÖ Backend retorna: `{total: 3, movies: [45, 42, 25]}`
5. ‚úÖ La pel√≠cula aparece inmediatamente en la UI sin refrescar

---

**Prioridad**: üî¥ **ALTA** - Funcionalidad core no funciona correctamente  
**Fecha**: 21 de Octubre, 2025  
**Reportado por**: Frontend Team
